---
layout: post
title: Leetcode[147] Insertion Sort List
---
###Task1
Sort a linked list using insertion sort.

###Python
####DNode
```python
class DNode(object):
    def __init__(self, x, k):
        self.val = x
        self.key = k
        self.prev = None
        self.next = None
class LRUCache(object):

    def __init__(self, capacity):
        """
        :type capacity: int
        """
        self.size = capacity
        self.head = DNode(-1, -1)
        self.tail = DNode(-1, -1)
        self.head.next = self.tail
        self.tail.prev = self.head
        self.dic = dict()

    def get(self, key):
        """
        :rtype: int
        """
        if key not in self.dic:
            return -1
        node = self.dic[key]
        node.prev.next = node.next
        node.next.prev = node.prev
        self.move2Tail(node)
        return node.val
        

    def set(self, key, value):
        """
        :type key: int
        :type value: int
        :rtype: nothing
        """
        if self.get(key) != -1:
            self.dic[key].val = value
            return
        if len(self.dic) >= self.size:
            del self.dic[self.head.next.key]
            self.head.next = self.head.next.next
            self.head.next.prev = self.head
        node = DNode(value, key)
        self.dic[key] = node
        self.move2Tail(node)
        
    def move2Tail(self, node):
        self.tail.prev.next = node
        node.prev = self.tail.prev
        self.tail.prev = node
        node.next = self.tail
        
    
```

####collections.OrderedDict()
```python
class LRUCache(object):

    def __init__(self, capacity):
        """
        :type capacity: int
        """
        self.size = capacity
        self.dic = collections.OrderedDict()

    def get(self, key):
        """
        :rtype: int
        """
        if key not in self.dic:
            return -1
        value = self.dic[key]
        del self.dic[key]
        self.dic[key] = value
        return value

    def set(self, key, value):
        """
        :type key: int
        :type value: int
        :rtype: nothing
        """
        if key in self.dic:
            del self.dic[key]
            self.dic[key] = value
            return
        if len(self.dic) == self.size:
            self.dic.popitem(last = False)
        self.dic[key] = value
                
```
###Java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
// class ListNode {
// 	int val;
// 	ListNode next;
// 	ListNode(int x) {
// 		val = x;
// 	}
// }
public class Solution {
    public ListNode insertionSortList(ListNode head) {
        if (head == null) {
        	return null;
        }
        ListNode dummy = new ListNode(head.val);
        ListNode pointer = head.next;

        while (pointer != null) {
        	ListNode innerPointer = dummy;
        	ListNode next = pointer.next;
    		//head
    		if (pointer.val <= dummy.val) {
    			ListNode oldHead = dummy;
    			dummy = pointer;
    			dummy.next = oldHead;
    		}      	
        	while (innerPointer.next != null) {
        		//middle
        		if (pointer.val > innerPointer.val && pointer.val <= innerPointer.next.val) {
        			ListNode oldNext = innerPointer.next;
        			innerPointer.next = pointer;
        			pointer.next = oldNext;
        			break;
        		}
        		innerPointer = innerPointer.next;
        	}
    		//tail
    		if (innerPointer.next == null && pointer.val > innerPointer.val) {
    			innerPointer.next = pointer;
    			pointer.next = null;
    		}
        	pointer = next;
        }

        return dummy;
    }
}

```
###Points

* PAT: every set() will call get() instead of search in dict.key. Cause get() will re-order the structure.
* python black magic: ordered dict